---
description: "Testing patterns for Vitest (UI) and Pytest (API)"
globs: ["**/*.test.{ts,tsx}", "**/tests/**/*.py", "**/conftest.py"]
---

# Testing Guidelines

## Test Frameworks

| Package | Framework | Location |
|---------|-----------|----------|
| UI | Vitest + React Testing Library | `packages/ui/src/**/*.test.tsx` (co-located) |
| API | Pytest | `packages/api/tests/` |
| DB | Pytest | `packages/db/tests/` |

## When to Add Tests

### Always Add Tests When

- Creating a component with user interactions or conditional logic
- Adding a new API endpoint
- Implementing business logic in hooks or utilities
- Fixing a bug (add regression test)

### Skip Tests When

- Creating purely presentational components with no logic
- Making trivial changes (typos, formatting)

## UI Testing (Vitest)

### Basic Component Test

```typescript
// button.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';
import { Button } from './button';

describe('Button', () => {
  it('renders with text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick when clicked', async () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);

    await userEvent.click(screen.getByRole('button'));

    expect(handleClick).toHaveBeenCalledOnce();
  });
});
```

### Testing with Providers

```typescript
import { renderWithProviders } from '@/test/test-utils';

it('fetches and displays data', async () => {
  renderWithProviders(<UserList />);

  await waitFor(() => {
    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });
});
```

### UI Test Commands

```bash
pnpm --filter ui test         # Watch mode
pnpm --filter ui test:run     # Run once
pnpm --filter ui test:coverage
```

## API Testing (Pytest)

### Fixtures (conftest.py)

```python
import pytest
from fastapi.testclient import TestClient
from src.main import app

@pytest.fixture
def client():
    """FastAPI test client fixture."""
    return TestClient(app)

@pytest.fixture
def health_response(client):
    """Get health check response data."""
    response = client.get("/health/")
    assert response.status_code == 200
    return response.json()
```

### Basic API Test

```python
def test_create_user(client):
    """Test creating a new user."""
    response = client.post("/users/", json={
        "name": "Test User",
        "email": "test@example.com"
    })

    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Test User"

def test_get_nonexistent_user(client):
    """Test 404 for missing user."""
    response = client.get("/users/99999")
    assert response.status_code == 404
```

### Using Test Helpers

```python
# helpers.py
def assert_service_exists(services: list, name: str) -> dict:
    """Assert a service exists and return it."""
    service = next((s for s in services if s["name"] == name), None)
    assert service is not None, f"Service '{name}' not found"
    return service

# In tests
from helpers import assert_service_exists

def test_api_service_healthy(health_response):
    api = assert_service_exists(health_response, "API")
    assert api["status"] == "healthy"
```

### API Test Commands

```bash
pnpm --filter api test
# or
cd packages/api && uv run pytest
```

## Test Patterns

### Arrange-Act-Assert

```python
def test_user_creation(client):
    # Arrange
    user_data = {"name": "Test", "email": "test@example.com"}

    # Act
    response = client.post("/users/", json=user_data)

    # Assert
    assert response.status_code == 201
```

### Test Edge Cases

- Empty inputs
- Invalid inputs
- Boundary values
- Error conditions (404, 401, 403)

## Running All Tests

```bash
pnpm test      # All packages
make test      # Same via Makefile
```
